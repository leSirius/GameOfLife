# 康威的生命游戏规则
生命游戏中，对于任意细胞，规则如下：
- 每个细胞有两种状态 - 存活或死亡，每个细胞与以自身为中心的周围八格细胞产生互动（如图，黑色为存活，白色为死亡）
- 当前细胞为存活状态时，当周围的存活细胞低于2个时（不包含2个），该细胞变成死亡状态。（模拟生命数量稀少）
- 当前细胞为存活状态时，当周围有2个或3个存活细胞时，该细胞保持原样。
- 当前细胞为存活状态时，当周围有超过3个存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）
- 当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。（模拟繁殖）
# 性能优化

1. 合并循环。每次执行每次重新计算状态并绘制时，从三个循环合并成两个或一个。几乎不节省计算量，有些语言可能用来提升缓存命中，这里没什么意义。
2. 移除react渲染。在一个小测试集上，每次update执行的脚本时间达到了10毫秒左右，经过排查原因是setState导致了react渲染。特别是，左侧控制栏上方的几个input和button组合（这里使用了NextUi库的组件），使用useMemo和memo优化（或者删除）这些组件可以使脚本时间减少到3毫秒左右。但把setState改为使用useRef追踪状态更好一些，这样用时0.5ms左右。(此外，在初始化时，这里面number类型的输入框会导致nav-bar组件重复渲染；更新时正常）
3. 并行。这个计算模型里除了邻居没有数据依赖，理论上来说是比较适合并行优化的。测试基于1000x1000，0.5稠密度。串行版本在初始阶段计算部分40-30ms，绘制成分250-200ms，后续总成本会降低到50-60ms左右；并行版本中,总运行事件通常初期在300ms左右，然后降低维持在200ms左右。并行的成本比较高，单一个postMessage调用常常花费主线程20-40ms。
> 对比《JavaScript权威指南》里曼德布洛特集合那个模型，对500x500的图做上亿次运算；这个模型的运算量太小了，对每个点的运算极端里算也不到20，而绘制面积却大得多。对于计算量不是非常大的大多数模型，Web Worker也许不太适合做并行上的考虑，更适合考虑并发一些
4. 稀疏矩阵。这个优化是每次更新画面，使用活跃点列表，然后把他们的邻居加入一个Map结构，最后遍历这个Map计算新的活跃点列表。这是一个糟糕的优化，跟先前一样的规模需要大几百毫秒。首先优化的点有问题，稀疏矩阵本身就没有触及性能瓶颈，而且计算量也不集中在那些无效遍历上；另外，引入了Map导致了更昂贵的数据操作，测试了一下，同样数量的操作，Map的for-of循环比Array慢7、8倍，set操作比列表直接赋值慢5倍。最多可以说在稀疏图的时候，这一版的存储效率好一些，稠密则也没有优势。

issues
- ArrayBuffer对象转移。
- console.time()比火花树方便

# SSR与动态导入
## 需求
canvas的绘制需要客户端的`window.devicePixelRatio`，与SSR冲突。框架默认的SSR需要用动态导入禁用。在服务端通过处理`undefined`设置默认值1以后，浏览器显示canvas的情况可以反映当前呈现的是哪里的绘制结果。
测试中的父组件是page组件，子组件是GameOfLife组件，页面主要元素在子组件。为了禁用SSR可以使用动态导入，这个子组件是初始渲染必须的，所以动态加载节省初始渲染成本的用途不适用。

现在的实现把`devicePixelRatio`的state放到`canvas.js`组件中，侧边栏使用一个参与缩放比计算的参数state，可以被预渲染了。

```
page.js  ->  GameOfLife.js  ->  canvas.js
                            ->  nav-bar.js
```
**动态导出**

动态导出是个随便起的描述，从StackOverflow看到的一个看起来意思的写法。在动态导入本文件包含的代码再导出，然后在做导入的文件写静态导入。
```
export default dynamic(() => Promise.resolve(Canvas), { ssr: false });
function Canvas(){...}
```

## 使用静态导入：
1. 浏览器呈现的是服务端预渲染的结果。报错服务端与客户端渲染结果（canvas的样式宽度）不匹配。刷新页面开启节流时才会察觉闪烁（除了蓝色背景外所有的内容消失重绘一下）。

: 浏览器收到的一个预渲染完成的html，然后客户端react组件在浏览器执行并水合。react-dom会报错提示渲染服务端与服务端渲染结果不同。因为页面是直接解析html渲染的，不用等待JS加载与执行，这种呈现方式是最快的.

2. 当在子组件中未处理`undefined`就使用依赖浏览器环境的值时，浏览器会呈现本地渲染的页面结果，刷新会闪白屏。错误码`500`。

: 在使用window对象等依赖浏览器的变量时，子组件的预渲染因为undefined导致渲染失败，收到的html是空的（成功html会有蓝色背景），服务端会报错渲染失败的错误。页面内容全由js加载和解析提供，所以空白时间明显增加。服务端环境与客户端对undefined的处理不同。

## 使用动态导入
显式禁用ssr，浏览器总是得到一个几乎为空的HTML，初始呈现速度较SSR慢：

1. 如果父组件是客户端组件，导入方式为动态导入。GameOfLife在一个单独的js文件中，对这个js的请求由page.js发起。

: 浏览器收到html文件，从`<header>`里请求page.js文件（async属性），然后等page.js加载完执行时请求game-of-life组件文件。
 preload scanner可以优化`<header>`里的请求，不（该）优化对game-of-life组件的请求，所以请求很迟，请求发起时间在600ms-800ms之间，有时比`<header>`中的ico文件还晚。（懒加载典型情况）

2. 如果父组件是客户端组件，导入方式为在子组件动态导出。GameOfLife组件打包进page.js，没有分包传输。

: 父组件静态导入，子组件编译时被打包进了page.js，当page.js执行到相应位置的时候可以从本文件获取导入的组件，不再发起请求。在只想要禁用SSR的需求下，这种设置比前一个效率高。

3. 如果父组件是服务端组件，导入方式为在子组件动态导出。GameOfLife组件打包进page.js，没有分包传输。

4. 如果父组件是服务端组件，导入方式为在父组件动态导入。GameOfLife组件打包进page.js，没有分包传输。

父组件是服务端组件的情况下，浏览器上的执行情况没有发现或想到明显区别。



